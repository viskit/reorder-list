{"mappings":";;ACuBA,wBAAyB,SAAQ,UAAU;IACzC,MAAM,CAAC,MAAM,0BAIX;IAGF,MAAM,UAAS;IAGf,QAAQ,UAAS;IAEjB,MAAM,EAAE,WAAW,CAAC;IAEpB,cAAc,EAAE,WAAW,CAAC;IAE5B,YAAY;IAwCZ,MAAM;IAwBN,OAAO,EAAE,OAAO,CAAC;IAGjB,GAAG,EAAE,WAAW,CAAC;IAGjB,iBAAiB,SAAM;IAWvB,UAAU,EAAE,WAAW,EAAE,CAAU;IAE7B,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC;IAYnC,QAAQ,CAAC,SAAS,EAAE,WAAW;IAM/B,KAAK,CAAC,EAAE,EAAE,QAAQ,GAAG,YAAY;IAmBjC,MAAM,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,EAAE,EAAE,SAAS;IAI7C,SAAS,CAAC,EACR,IAAI,EACJ,CAAC,EACD,SAAS,EACT,UAAU,EACV,SAAS,EACT,cAAc,EACd,SAAS,EACT,cAAc,EACd,aAAa,EACb,aAAa,GACd,EAAE,YAAY;IAuGf,MAAM,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,EAAE,SAAS;CAKrC;AAGD,QAAQ,MAAM,CAAC;IACb,UAAU,qBAAqB;QAC7B,qBAAqB,EAAE,WAAW,CAAC;KACpC;CACF","sources":["src/src/cloneWithShadowRoots.ts","src/src/index.ts","src/index.ts"],"sourcesContent":[null,null,"import \"@viskit/reorder\";\nimport {\n  Reorder,\n  StartEvent,\n  DropEvent,\n  ReorderEvent,\n  DragEvent,\n  EndEvent,\n} from \"@viskit/reorder\";\nimport { GestureDetail } from \"@ionic/core\";\nimport { LitElement, html, css } from \"lit\";\nimport { query, property, state } from \"lit/decorators.js\";\nimport {cloneWithShadowRoots} from \"./cloneWithShadowRoots\";\nimport { register } from \"@viskit/long-press\";\n\nconst clear = (children: HTMLCollection, deep = false) => {\n  const childrens = Array.from(children) as HTMLElement[];\n  childrens.forEach((c) => {\n    c.style.transform = \"\";\n    deep && (c.style.transition = \"\");\n  });\n};\n\nexport class ReorderList extends LitElement {\n  static styles = css`\n    :host {\n      display: block;\n    }\n  `;\n\n  @property({ type: Boolean })\n  enable = false;\n\n  @state()\n  inEnable = false;\n\n  dragEl: HTMLElement;\n\n  selectedDragEl: HTMLElement;\n\n  firstUpdated() {\n    register(this.shadowRoot);\n    this.addEventListener(\n      \"long-press\",\n      (e: PointerEvent) => {\n        const draggable = this.selectedDragEl;\n        if (draggable) {\n          this.inEnable = true;\n\n          const dragEl = cloneWithShadowRoots(draggable) as HTMLElement;\n          const styles = window.getComputedStyle(draggable);\n\n          for (let i = 0, len = styles.length; i < len; i++) {\n            const key = styles.item(i);\n            dragEl.style.setProperty(key, styles.getPropertyValue(key));\n          }\n\n          const { left, top, width, height } =\n            draggable.getBoundingClientRect();\n          dragEl.style.position = \"absolute\";\n          dragEl.style.top = top + \"px\";\n          dragEl.style.left = left + \"px\";\n          dragEl.style.pointerEvents = \"none\";\n          dragEl.style.margin = \"0\";\n          dragEl.style.width = width + \"px\";\n          dragEl.style.height = height + \"px\";\n          dragEl.style.transition = \"\";\n          dragEl.style.boxShadow = \"5px 5px 5px #333\";\n\n          document.body.appendChild(dragEl);\n\n          this.dragEl = dragEl;\n\n          (draggable as HTMLElement).style.opacity = \"0\";\n        }\n      },\n      true\n    );\n  }\n\n  render() {\n    return html`\n      <viskit-reorder\n        .enable=${this.enable && this.inEnable}\n        .canStart=${(e: GestureDetail) => {\n          this.selectedDragEl = e.data.draggable;\n          return true;\n        }}\n        @viskit-start=${() => {\n          this.dispatchEvent(new CustomEvent(\"viskit-start\"));\n        }}\n        @viskit-drag=${this.onDrag}\n        @viskit-reorder=${this.onReorder}\n        @viskit-drop=${this.onDrop}\n        @viskit-end=${this.onEnd}\n        @pointerup=${this.onEnd}\n        .containers=${this.containers}\n      >\n        <slot></slot>\n      </viskit-reorder>\n    `;\n  }\n\n  @query(\"viskit-reorder\")\n  reorder: Reorder;\n\n  @query(\"div\")\n  div: HTMLElement;\n\n  @property()\n  containerSelector = \"\";\n\n  @property({\n    attribute: false,\n    hasChanged(containers) {\n      return (\n        Array.isArray(containers) &&\n        containers.every((c) => c instanceof HTMLElement)\n      );\n    },\n  })\n  containers: HTMLElement[] = [this];\n\n  async updated(map: Map<string, any>) {\n    if (map.has(\"containerSelector\") && this.containerSelector) {\n      this.containers = Array.from(\n        this.querySelectorAll(this.containerSelector)\n      ) as HTMLElement[];\n    }\n\n    if (map.has(\"containers\") && this.containers) {\n      this.containers.forEach((c) => this.addStyle(c));\n    }\n  }\n\n  addStyle(container: HTMLElement) {\n    (Array.from(container.children) as HTMLElement[]).forEach((el) => {\n      el.style.transition = \"transform .2s\";\n    });\n  }\n\n  onEnd(ev: EndEvent | PointerEvent) {\n    if (this.inEnable) {\n      this.inEnable = false;\n    }\n\n    const data = (ev as EndEvent).data;\n    if (data) {\n      data.hoverContainer && clear(data.hoverContainer.children);\n      data.container && clear(data.container.children, true);\n      this.dispatchEvent(new CustomEvent(\"viskit-end\"));\n    }\n\n    if (this.selectedDragEl) {\n      this.selectedDragEl.style.setProperty(\"opacity\", \"unset\");\n      this.selectedDragEl = null;\n    }\n    this.dragEl && this.dragEl.remove();\n  }\n\n  onDrag({ data, deltaY, container }: DragEvent) {\n    this.dragEl.style.transform = `translateY(${deltaY}px)`;\n  }\n\n  onReorder({\n    data,\n    y,\n    container,\n    hoverIndex,\n    hoverable,\n    hoverContainer,\n    draggable,\n    draggableIndex,\n    draggableRect,\n    hoverableRect,\n  }: ReorderEvent) {\n    if (hoverableRect && draggableRect) {\n      const prevHoverContainer = data.hoverContainer as HTMLElement;\n\n      // clear prev\n\n      let index = hoverIndex;\n\n      // clear previous cntainer's children transform\n      if (prevHoverContainer !== hoverContainer && prevHoverContainer) {\n        clear(prevHoverContainer.children);\n      }\n\n      if (container === hoverContainer) {\n        if (hoverIndex === draggableIndex) {\n          clear(hoverContainer.children);\n        } else if (hoverIndex < draggableIndex) {\n          if (y > hoverableRect.top + hoverableRect.height / 2) {\n            ++index;\n            data.after = true;\n          } else {\n            data.after = false;\n          }\n          if (index === draggableIndex) {\n            clear(hoverContainer.children);\n          } else {\n            const children = Array.from(\n              hoverContainer.children\n            ) as HTMLElement[];\n            this.addStyle(hoverContainer);\n            for (let i = 0, len = children.length; i < len; i++) {\n              let y = 0;\n              if (i >= index && i < draggableIndex) {\n                y = draggableRect.height;\n              }\n              children[i].style.transform = `translateY(${y}px)`;\n            }\n          }\n        } else {\n          if (y < hoverableRect.top + hoverableRect.height / 2) {\n            --index;\n            data.after = false;\n          } else {\n            data.after = true;\n          }\n\n          if (index === draggableIndex) {\n            clear(hoverContainer.children);\n          } else {\n            const children = Array.from(\n              hoverContainer.children\n            ) as HTMLElement[];\n            this.addStyle(hoverContainer);\n            for (let i = 0, len = children.length; i < len; i++) {\n              let y = 0;\n              if (i > draggableIndex && i <= index) {\n                y = -draggableRect.height;\n              }\n\n              children[i].style.transform = `translateY(${y}px)`;\n            }\n          }\n        }\n      } else {\n        const fromTop = draggableRect.top < hoverableRect.top;\n\n        if (y > hoverableRect.top + hoverableRect.height / 2) {\n          ++index;\n          data.after = true;\n        } else {\n          data.after = false;\n        }\n        const children = Array.from(hoverContainer.children) as HTMLElement[];\n        for (let i = 0, len = children.length; i < len; i++) {\n          let y = 0;\n\n          if (index === children.length) {\n            y = -draggableRect.height;\n          } else {\n            if (i >= index) {\n              y = draggableRect.height;\n            }\n          }\n\n          this.addStyle(hoverContainer);\n\n          if (\n            (fromTop && hoverIndex === 0 && !data.after) ||\n            (!fromTop &&\n              hoverIndex === hoverContainer.children.length - 1 &&\n              data.after)\n          ) {\n            y = y / 2;\n          }\n          children[i].style.transform = `translateY(${y}px)`;\n        }\n      }\n\n      data.hoverContainer = hoverContainer;\n      data.dropIndex = index;\n    }\n  }\n\n  onDrop({ data, complete }: DropEvent) {\n    if (data.draggable !== data.hoverable) {\n      complete(data.after);\n    }\n  }\n}\n\nwindow.customElements.define(\"viskit-reorder-list\", ReorderList);\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"viskit-reorder-list\": ReorderList;\n  }\n}\n"],"names":[],"version":3,"file":"types.d.ts.map"}